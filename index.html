<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DSRT Image Editor - Lengkap Siap Pakai</title>
<style>
  /* Reset & base */
  * { box-sizing: border-box; }
  body, html { margin:0; padding:0; height:100vh; font-family: Poppins, sans-serif; background:#121212; color:#eee; }
  #app { display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

  /* Header */
  header {
    height: 50px; background:#222; display: flex; align-items:center; padding: 0 10px;
  }
  #backBtn {
    background:none; border:none; color:#0ff; font-size:24px; cursor:pointer; margin-right:10px;
  }
  #logo { font-weight:700; font-size: 20px; flex-grow:1; }
  #menuToggle {
    background:none; border:none; color:#0ff; font-size:28px; cursor:pointer;
    display:none; /* only mobile */
  }
  @media(max-width:900px) {
    #menuToggle { display:inline-block; }
  }

  /* Main area */
  #main {
    flex-grow:1; display: flex; overflow: hidden;
  }

  /* Sidebar kiri */
  #sidebarLeft {
    width: 250px; background:#222; padding:10px; overflow-y: auto;
    transition: transform 0.3s ease;
  }
  #sidebarLeft.hide {
    transform: translateX(-260px);
  }
  #sidebarLeft h3 {
    margin-top:0; margin-bottom:10px; color:#0ff; border-bottom: 1px solid #0ff;
  }
  #sidebarLeft button.toolBtn {
    width: 100%; margin:5px 0; padding:8px; background:#333; border:none; color:#0ff; font-weight:600; cursor:pointer;
    border-radius: 4px;
    user-select:none;
    transition: background-color 0.3s;
  }
  #sidebarLeft button.toolBtn.active {
    background:#0ff; color:#222;
  }
  #closeSidebar {
    background:none; border:none; color:#f33; font-size: 28px; float:right; cursor:pointer;
  }

  /* Sidebar kanan */
  #sidebarRight {
    width: 250px; background:#222; padding:10px; overflow-y: auto;
    color:#0ff;
    transition: transform 0.3s ease;
  }
  #sidebarRight.hide {
    transform: translateX(260px);
  }
  #sidebarRight h3 {
    margin-top:0; margin-bottom:10px; border-bottom:1px solid #0ff;
  }
  #sidebarRight label {
    display:block; margin-top:10px;
  }
  #sidebarRight input[type=range] {
    width: 100%;
  }

  /* Canvas container */
  #canvasContainer {
    flex-grow:1; background:#111; display:flex; justify-content:center; align-items:center; position: relative;
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    background:#222;
    max-width: 100%;
    max-height: 100%;
    user-select:none;
    touch-action:none;
    cursor: crosshair;
    image-rendering: pixelated;
    border-radius:4px;
  }

  /* Footer toolbar */
  footer {
    height: 50px; background:#222; display:flex; align-items:center; justify-content:center; gap:15px;
    padding:0 10px;
  }
  footer button {
    background:#0ff; border:none; padding:8px 12px; border-radius:4px; font-weight:700; cursor:pointer;
    color:#222;
    user-select:none;
    transition: background-color 0.3s;
  }
  footer button:disabled {
    background:#444; cursor:not-allowed; color:#888;
  }

  /* Upload button floating */
  #uploadBtn {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 10;
    background:#0ff;
    border:none;
    padding: 6px 12px;
    border-radius: 4px;
    font-weight: 600;
    color:#222;
    cursor:pointer;
  }
  #uploadInput {
    display:none;
  }

  /* Responsive */
  @media(max-width:900px){
    #sidebarLeft, #sidebarRight {
      position: fixed;
      top: 50px; bottom: 50px;
      z-index: 20;
      box-shadow: 2px 0 8px rgba(0,0,0,0.8);
      background:#222;
    }
    #sidebarLeft.hide {
      transform: translateX(-260px);
    }
    #sidebarRight.hide {
      transform: translateX(260px);
    }
    #menuToggle { display:inline-block; }
    #sidebarRight { right: 0; }
    #sidebarLeft { left: 0; }
    #canvasContainer {
      flex-grow:1; /* full area under header/footer */
    }
  }
</style>
</head>
<body>
<div id="app">
  <header>
    <button id="backBtn" title="Back">&#8592;</button>
    <div id="logo">DSRT Image Editor</div>
    <button id="menuToggle" title="Toggle Menu">&#9776;</button>
  </header>
  <div id="main">
    <aside id="sidebarLeft" class="hide" aria-label="Sidebar tools">
      <button id="closeSidebar" title="Close Sidebar">&times;</button>
      <h3>Manual Tools</h3>
      <button class="toolBtn" data-tool="crop">Crop</button>
      <button class="toolBtn" data-tool="rotate">Rotate 90°</button>
      <button class="toolBtn" data-tool="brush">Brush</button>
      <button class="toolBtn" data-tool="eraser">Eraser</button>
      <h3>Restoration</h3>
      <button class="toolBtn" data-tool="spotHealing">Spot Healing</button>
      <button class="toolBtn" data-tool="cloneStamp">Clone Stamp</button>
      <h3>Filters</h3>
      <button class="toolBtn" data-tool="brightness">Brightness</button>
      <button class="toolBtn" data-tool="contrast">Contrast</button>
      <button class="toolBtn" data-tool="grayscale">Grayscale</button>
      <button class="toolBtn" data-tool="sepia">Sepia</button>
      <button class="toolBtn" data-tool="invert">Invert</button>
    </aside>

    <div id="canvasContainer" tabindex="0" aria-label="Image editing canvas">
      <input type="file" id="uploadInput" accept="image/*" />
      <button id="uploadBtn" title="Upload Image">Choose File</button>
      <canvas id="canvas" width="800" height="600"></canvas>
    </div>

    <aside id="sidebarRight" class="hide" aria-label="Tool properties">
      <h3>Properties</h3>
      <div id="toolProperties">Pilih tool dulu</div>
    </aside>
  </div>

  <footer>
    <button id="undoBtn" disabled>Undo</button>
    <button id="redoBtn" disabled>Redo</button>
    <button id="zoomInBtn">Zoom In</button>
    <button id="zoomOutBtn">Zoom Out</button>
    <button id="resetViewBtn">Reset View</button>
    <button id="saveBtn" disabled>Save</button>
    <button id="exportBtn" disabled>Export</button>
  </footer>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // State
  let img = new Image();
  let imgLoaded = false;
  let scale = 1;
  let offsetX = 0;
  let offsetY = 0;

  // Undo stack
  const undoStack = [];
  const redoStack = [];
  const maxHistory = 20;

  // Current tool and params
  let currentTool = null;
  let brushSize = 15;
  let eraserSize = 20;

  // Crop vars
  let cropStart = null;
  let cropEnd = null;
  let isCropping = false;

  // Drawing flags
  let isDrawing = false;
  let lastPos = null;

  // Clone stamp vars
  let cloneSourcePos = null;

  // DOM Elements
  const sidebarLeft = document.getElementById('sidebarLeft');
  const sidebarRight = document.getElementById('sidebarRight');
  const menuToggle = document.getElementById('menuToggle');
  const closeSidebar = document.getElementById('closeSidebar');
  const uploadInput = document.getElementById('uploadInput');
  const uploadBtn = document.getElementById('uploadBtn');
  const backBtn = document.getElementById('backBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetViewBtn = document.getElementById('resetViewBtn');
  const saveBtn = document.getElementById('saveBtn');
  const exportBtn = document.getElementById('exportBtn');
  const toolButtons = document.querySelectorAll('.toolBtn');
  const toolProperties = document.getElementById('toolProperties');

  // Helper: clamp color values
  function clamp(v){ return Math.max(0, Math.min(255, v)); }

  // Draw image with transform
  function draw(){
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if(!imgLoaded) return;
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    ctx.drawImage(img, 0, 0);
    ctx.restore();

    if(currentTool==='crop' && cropStart && cropEnd){
      drawCropRect();
    }
  }

  // Load image and reset state
  function loadImage(image){
    img = image;
    imgLoaded = true;
    scale = 1;
    offsetX = 0;
    offsetY = 0;

    // Resize canvas max 800x600 keeping ratio
    let w = img.width;
    let h = img.height;
    const maxW = 800;
    const maxH = 600;
    if(w > maxW){
      h = h * maxW / w;
      w = maxW;
    }
    if(h > maxH){
      w = w * maxH / h;
      h = maxH;
    }
    canvas.width = w;
    canvas.height = h;

    saveState();
    draw();
    saveBtn.disabled = false;
    exportBtn.disabled = false;
  }

  // Save canvas state for undo
  function saveState(){
    if(!imgLoaded) return;
    if(undoStack.length >= maxHistory){
      undoStack.shift();
    }
    undoStack.push(canvas.toDataURL());
    redoStack.length = 0;
    updateUndoRedoButtons();
  }

  // Restore from dataURL
  function restoreFromDataUrl(dataUrl){
    const tmpImg = new Image();
    tmpImg.onload = () => {
      img = tmpImg;
      imgLoaded = true;
      canvas.width = img.width;
      canvas.height = img.height;
      draw();
    };
    tmpImg.src = dataUrl;
  }

  // Update Undo/Redo buttons disabled state
  function updateUndoRedoButtons(){
    undoBtn.disabled = undoStack.length <= 1;
    redoBtn.disabled = redoStack.length === 0;
  }

  // Undo action
  undoBtn.onclick = () => {
    if(undoStack.length > 1){
      const last = undoStack.pop();
      redoStack.push(last);
      const prev = undoStack[undoStack.length -1];
      restoreFromDataUrl(prev);
      updateUndoRedoButtons();
    }
  };

  // Redo action
  redoBtn.onclick = () => {
    if(redoStack.length > 0){
      const redo = redoStack.pop();
      undoStack.push(redo);
      restoreFromDataUrl(redo);
      updateUndoRedoButtons();
    }
  };

  // Upload handler
  uploadInput.addEventListener('change', e => {
    if(e.target.files.length === 0) return;
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = evt => {
      const image = new Image();
      image.onload = () => loadImage(image);
      image.src = evt.target.result;
    };
    reader.readAsDataURL(file);
  });
  uploadBtn.onclick = () => uploadInput.click();

  // Menu toggle for mobile
  menuToggle.onclick = () => {
    sidebarLeft.classList.toggle('hide');
  };
  closeSidebar.onclick = () => sidebarLeft.classList.add('hide');

  // Back button resets all
  backBtn.onclick = () => {
    if(confirm("Reset semua dan mulai ulang?")){
      undoStack.length = 0;
      redoStack.length = 0;
      imgLoaded = false;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      saveBtn.disabled = true;
      exportBtn.disabled = true;
      toolButtons.forEach(b => b.classList.remove('active'));
      currentTool = null;
      sidebarRight.classList.add('hide');
      draw();
    }
  };

  // Tool buttons click
  toolButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      if(currentTool === btn.dataset.tool){
        currentTool = null;
        btn.classList.remove('active');
        sidebarRight.classList.add('hide');
        toolProperties.innerHTML = 'Pilih tool dulu';
        canvas.style.cursor = 'default';
      } else {
        currentTool = btn.dataset.tool;
        toolButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        updatePropertiesPanel(currentTool);
        sidebarRight.classList.remove('hide');
        canvas.style.cursor = (currentTool==='brush' || currentTool==='eraser' || currentTool==='spotHealing' || currentTool==='cloneStamp') ? 'crosshair' : 'default';
      }
    });
  });

  // Update properties panel depending on tool
  function updatePropertiesPanel(tool){
    let html = '';
    switch(tool){
      case 'brush':
        html = `<label>Brush Size: <input type="range" id="brushSize" min="1" max="50" value="${brushSize}"></label>`;
        break;
      case 'eraser':
        html = `<label>Eraser Size: <input type="range" id="eraserSize" min="1" max="50" value="${eraserSize}"></label>`;
        break;
      case 'brightness':
      case 'contrast':
        html = `<label>${tool.charAt(0).toUpperCase() + tool.slice(1)}: <input type="range" id="${tool}Range" min="-100" max="100" value="0"></label>`;
        break;
      case 'crop':
        html = `<p>Drag di canvas untuk memilih area crop, lalu klik Apply Crop di bawah.</p><button id="applyCropBtn">Apply Crop</button>`;
        break;
      case 'rotate':
        html = `<button id="rotateBtn">Putar 90°</button>`;
        break;
      case 'spotHealing':
        html = `<p>Gunakan kuas untuk menghapus noda dengan blur.</p><label>Brush Size: <input type="range" id="brushSize" min="1" max="50" value="${brushSize}"></label>`;
        break;
      case 'cloneStamp':
        html = `<p>Klik area sumber lalu kuas area target.</p><label>Brush Size: <input type="range" id="brushSize" min="1" max="50" value="${brushSize}"></label>`;
        break;
      default:
        html = `<p>Atur properti jika ada.</p>`;
    }
    toolProperties.innerHTML = html;

    if(tool==='brush'){
      document.getElementById('brushSize').addEventListener('input', e => brushSize = +e.target.value);
    }
    if(tool==='eraser'){
      document.getElementById('eraserSize').addEventListener('input', e => eraserSize = +e.target.value);
    }
    if(tool==='brightness'){
      document.getElementById('brightnessRange').addEventListener('input', e => applyFilter('brightness', +e.target.value));
    }
    if(tool==='contrast'){
      document.getElementById('contrastRange').addEventListener('input', e => applyFilter('contrast', +e.target.value));
    }
    if(tool==='crop'){
      document.getElementById('applyCropBtn').addEventListener('click', applyCrop);
    }
    if(tool==='rotate'){
      document.getElementById('rotateBtn').addEventListener('click', rotateImage);
    }
    if(tool==='spotHealing'){
      document.getElementById('brushSize').addEventListener('input', e => brushSize = +e.target.value);
    }
    if(tool==='cloneStamp'){
      document.getElementById('brushSize').addEventListener('input', e => brushSize = +e.target.value);
    }
  }

  // Get canvas mouse/touch pos relative to canvas coords
  function getCanvasPos(evt){
    const rect = canvas.getBoundingClientRect();
    let x, y;
if(evt.touches){
      x = evt.touches[0].clientX - rect.left;
      y = evt.touches[0].clientY - rect.top;
    } else {
      x = evt.clientX - rect.left;
      y = evt.clientY - rect.top;
    }
    // Sesuaikan dengan offset dan scale
    x = (x - offsetX) / scale;
    y = (y - offsetY) / scale;
    return {x, y};
  }

  // Crop drawing rectangle overlay
  function drawCropRect(){
    if(!cropStart || !cropEnd) return;
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 2 / scale;
    const x = Math.min(cropStart.x, cropEnd.x);
    const y = Math.min(cropStart.y, cropEnd.y);
    const w = Math.abs(cropStart.x - cropEnd.x);
    const h = Math.abs(cropStart.y - cropEnd.y);
    ctx.strokeRect(x, y, w, h);
    ctx.restore();
  }

  // Apply crop action
  function applyCrop(){
    if(!cropStart || !cropEnd) return alert('Pilih area crop dulu!');
    const x = Math.min(cropStart.x, cropEnd.x);
    const y = Math.min(cropStart.y, cropEnd.y);
    const w = Math.abs(cropStart.x - cropEnd.x);
    const h = Math.abs(cropStart.y - cropEnd.y);
    if(w < 10 || h < 10) return alert('Area crop terlalu kecil!');
    // Buat canvas baru untuk crop
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = w;
    tempCanvas.height = h;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(img, x, y, w, h, 0, 0, w, h);

    // Update img and canvas
    img.src = tempCanvas.toDataURL();
    img.onload = () => {
      canvas.width = w;
      canvas.height = h;
      offsetX = 0;
      offsetY = 0;
      scale = 1;
      saveState();
      draw();
    };
    // Reset crop vars
    cropStart = null;
    cropEnd = null;
    isCropping = false;
  }

  // Rotate image 90° clockwise
  function rotateImage(){
    if(!imgLoaded) return;
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = img.height;
    tempCanvas.height = img.width;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.translate(tempCanvas.width/2, tempCanvas.height/2);
    tempCtx.rotate(Math.PI/2);
    tempCtx.drawImage(img, -img.width/2, -img.height/2);
    img.src = tempCanvas.toDataURL();
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      offsetX = 0;
      offsetY = 0;
      scale = 1;
      saveState();
      draw();
    };
  }

  // Apply filters brightness/contrast/grayscale/sepia/invert
  function applyFilter(type, value=0){
    if(!imgLoaded) return;
    const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = imageData.data;
    switch(type){
      case 'brightness':
        for(let i=0; i<data.length; i+=4){
          data[i] = clamp(data[i] + value*2.55);
          data[i+1] = clamp(data[i+1] + value*2.55);
          data[i+2] = clamp(data[i+2] + value*2.55);
        }
        break;
      case 'contrast':
        let factor = (259 * (value + 255)) / (255 * (259 - value));
        for(let i=0; i<data.length; i+=4){
          data[i] = clamp(factor * (data[i] - 128) + 128);
          data[i+1] = clamp(factor * (data[i+1] - 128) + 128);
          data[i+2] = clamp(factor * (data[i+2] - 128) + 128);
        }
        break;
      case 'grayscale':
        for(let i=0; i<data.length; i+=4){
          let avg = (data[i] + data[i+1] + data[i+2]) /3;
          data[i] = data[i+1] = data[i+2] = avg;
        }
        break;
      case 'sepia':
        for(let i=0; i<data.length; i+=4){
          let r = data[i], g = data[i+1], b = data[i+2];
          data[i] = clamp((r*0.393) + (g*0.769) + (b*0.189));
          data[i+1] = clamp((r*0.349) + (g*0.686) + (b*0.168));
          data[i+2] = clamp((r*0.272) + (g*0.534) + (b*0.131));
        }
        break;
      case 'invert':
        for(let i=0; i<data.length; i+=4){
          data[i] = 255 - data[i];
          data[i+1] = 255 - data[i+1];
          data[i+2] = 255 - data[i+2];
        }
        break;
    }
    ctx.putImageData(imageData, 0, 0);
    saveState();
  }

  // Drawing with brush or eraser or spotHealing or cloneStamp
  function drawLine(x1,y1,x2,y2, toolType){
    if(!imgLoaded) return;
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);

    switch(toolType){
      case 'brush':
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = brushSize / scale;
        ctx.globalCompositeOperation = 'source-over';
        break;
      case 'eraser':
        ctx.strokeStyle = 'rgba(0,0,0,1)';
        ctx.lineWidth = eraserSize / scale;
        ctx.globalCompositeOperation = 'destination-out';
        break;
      case 'spotHealing':
        // Simple spot healing: blur area along line
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.lineWidth = brushSize / scale;
        ctx.globalCompositeOperation = 'source-over';
        break;
      case 'cloneStamp':
        // For clone stamp, draw from cloneSourcePos to current pos (simplified)
        if(!cloneSourcePos) break;
        let dx = x2 - x1;
        let dy = y2 - y1;
        const cloneX = cloneSourcePos.x + dx;
        const cloneY = cloneSourcePos.y + dy;
        ctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(canvas, cloneX - brushSize/2, cloneY - brushSize/2, brushSize, brushSize, x2 - brushSize/2, y2 - brushSize/2, brushSize, brushSize);
        ctx.restore();
        return;
      default:
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 5;
    }

    ctx.stroke();
    ctx.restore();

    saveState();
  }

  // Mouse & Touch Events
  canvas.addEventListener('mousedown', e => {
    if(!imgLoaded) return;
    const pos = getCanvasPos(e);
    if(currentTool === 'crop'){
      cropStart = pos;
      cropEnd = null;
      isCropping = true;
      draw();
    } else if(['brush', 'eraser', 'spotHealing', 'cloneStamp'].includes(currentTool)){
      isDrawing = true;
      lastPos = pos;
      if(currentTool === 'cloneStamp'){
        if(!cloneSourcePos){
          cloneSourcePos = pos;
          alert('Clone source area set. Sekarang sapukan kuas ke target area.');
          return;
        }
      }
    }
  });

  canvas.addEventListener('mousemove', e => {
    if(!imgLoaded) return;
    if(currentTool === 'crop' && isCropping){
      cropEnd = getCanvasPos(e);
      draw();
      drawCropRect();
    }
    if(isDrawing){
      const pos = getCanvasPos(e);
      drawLine(lastPos.x, lastPos.y, pos.x, pos.y, currentTool);
      lastPos = pos;
    }
  });

  canvas.addEventListener('mouseup', e => {
    if(currentTool === 'crop' && isCropping){
      cropEnd = getCanvasPos(e);
      isCropping = false;
      draw();
      drawCropRect();
    }
    if(isDrawing){
      isDrawing = false;
      lastPos = null;
    }
  });

  canvas.addEventListener('mouseleave', e => {
    if(isDrawing){
      isDrawing = false;
      lastPos = null;
    }
  });

  // Touch events for mobile
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    if(!imgLoaded) return;
    const pos = getCanvasPos(e);
    if(currentTool === 'crop'){
      cropStart = pos;
      cropEnd = null;
      isCropping = true;
      draw();
    } else if(['brush', 'eraser', 'spotHealing', 'cloneStamp'].includes(currentTool)){
      isDrawing = true;
      lastPos = pos;
      if(currentTool === 'cloneStamp'){
        if(!cloneSourcePos){
          cloneSourcePos = pos;
          alert('Clone source area set. Sekarang sapukan kuas ke target area.');
          return;
        }
      }
    }
  }, {passive:false});

  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if(!imgLoaded) return;
    if(currentTool === 'crop' && isCropping){
      cropEnd = getCanvasPos(e);
      draw();
      drawCropRect();
    }
    if(isDrawing){
      const pos = getCanvasPos(e);
      drawLine(lastPos.x, lastPos.y, pos.x, pos.y, currentTool);
      lastPos = pos;
    }
  }, {passive:false});

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if(currentTool === 'crop' && isCropping){
      cropEnd = getCanvasPos(e);
      isCropping = false;
      draw();
      drawCropRect();
    }
    if(isDrawing){
      isDrawing = false;
      lastPos = null;
    }
  }, {passive:false});

  // Zoom buttons
  zoomInBtn.onclick = () => {
    scale = Math.min(5, scale + 0.2);
    draw();
  };
  zoomOutBtn.onclick = () => {
    scale = Math.max(0.2, scale - 0.2);
    draw();
  };
  resetViewBtn.onclick = () => {
    scale = 1;
    offsetX = 0;
    offsetY = 0;
    draw();
  };

  // Save & Export (save as data URL or download PNG)
  saveBtn.onclick = () => {
    alert('Save fungsi sementara belum terintegrasi database atau backend.');
  };

  exportBtn.onclick = () => {
    if(!imgLoaded) return alert('Belum ada gambar untuk diekspor!');
    const dataURL = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = 'dsrt-image.png';
    a.click();
  };

  // Initial draw
  draw();
})();
</script>

</body>
</html>
