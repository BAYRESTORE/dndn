<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DSRT Image Editor</title>
<style>
  /* Reset & base */
  * { box-sizing: border-box; }
  body, html { margin:0; padding:0; height:100vh; font-family: Poppins, sans-serif; background:#121212; color:#eee; }
  #app { display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

  /* Header */
  header {
    height: 50px; background:#222; display: flex; align-items:center; padding: 0 10px;
  }
  #backBtn {
    background:none; border:none; color:#0ff; font-size:24px; cursor:pointer; margin-right:10px;
  }
  #logo { font-weight:700; font-size: 20px; flex-grow:1; }
  #menuToggle {
    background:none; border:none; color:#0ff; font-size:28px; cursor:pointer;
    display:none; /* only mobile */
  }
  @media(max-width:900px) {
    #menuToggle { display:inline-block; }
  }

  /* Main area */
  #main {
    flex-grow:1; display: flex; overflow: hidden;
  }

  /* Sidebar kiri */
  #sidebarLeft {
    width: 250px; background:#222; padding:10px; overflow-y: auto;
    transition: transform 0.3s ease;
  }
  #sidebarLeft.hide {
    transform: translateX(-260px);
  }
  #sidebarLeft h3 {
    margin-top:0; margin-bottom:10px; color:#0ff; border-bottom: 1px solid #0ff;
  }
  #sidebarLeft button.toolBtn {
    width: 100%; margin:5px 0; padding:8px; background:#333; border:none; color:#0ff; font-weight:600; cursor:pointer;
  }
  #sidebarLeft button.toolBtn.active {
    background:#0ff; color:#222;
  }
  #closeSidebar {
    background:none; border:none; color:#f33; font-size: 28px; float:right; cursor:pointer;
  }

  /* Sidebar kanan */
  #sidebarRight {
    width: 250px; background:#222; padding:10px; overflow-y: auto;
    color:#0ff;
    transition: transform 0.3s ease;
  }
  #sidebarRight.hide {
    transform: translateX(260px);
  }
  #sidebarRight h3 {
    margin-top:0; margin-bottom:10px; border-bottom:1px solid #0ff;
  }
  #sidebarRight label {
    display:block; margin-top:10px;
  }
  #sidebarRight input[type=range] {
    width: 100%;
  }

  /* Canvas container */
  #canvasContainer {
    flex-grow:1; background:#111; display:flex; justify-content:center; align-items:center; position: relative;
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    background:#222;
    max-width: 100%;
    max-height: 100%;
    user-select:none;
    touch-action:none;
    cursor: crosshair;
    image-rendering: pixelated;
    border-radius:4px;
  }

  /* Footer toolbar */
  footer {
    height: 50px; background:#222; display:flex; align-items:center; justify-content:center; gap:15px;
    padding:0 10px;
  }
  footer button {
    background:#0ff; border:none; padding:8px 12px; border-radius:4px; font-weight:700; cursor:pointer;
    color:#222;
    user-select:none;
  }
  footer button:disabled {
    background:#444; cursor:not-allowed; color:#888;
  }

  /* Upload button floating */
  #uploadBtn {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 10;
  }
  #uploadInput {
    display:none;
  }

  /* Responsive */
  @media(max-width:900px){
    #sidebarLeft, #sidebarRight {
      position: fixed;
      top: 50px; bottom: 50px;
      z-index: 20;
      box-shadow: 2px 0 8px rgba(0,0,0,0.8);
      background:#222;
    }
    #sidebarLeft.hide {
      transform: translateX(-260px);
    }
    #sidebarRight.hide {
      transform: translateX(260px);
    }
    #menuToggle { display:inline-block; }
    #sidebarRight { right: 0; }
    #sidebarLeft { left: 0; }
    #canvasContainer {
      flex-grow:1; /* full area under header/footer */
    }
  }
</style>
</head>
<body>
<div id="app">
  <header>
    <button id="backBtn" title="Back">&#8592;</button>
    <div id="logo">DSRT Image Editor</div>
    <button id="menuToggle" title="Toggle Menu">&#9776;</button>
  </header>
  <div id="main">
    <aside id="sidebarLeft" class="hide" aria-label="Sidebar tools">
      <button id="closeSidebar" title="Close Sidebar">&times;</button>
      <h3>Manual Tools</h3>
      <button class="toolBtn" data-tool="crop">Crop</button>
      <button class="toolBtn" data-tool="rotate">Rotate 90°</button>
      <button class="toolBtn" data-tool="brush">Brush</button>
      <button class="toolBtn" data-tool="eraser">Eraser</button>
      <h3>Restoration</h3>
      <button class="toolBtn" data-tool="spotHealing">Spot Healing</button>
      <button class="toolBtn" data-tool="cloneStamp">Clone Stamp</button>
      <h3>Filters</h3>
      <button class="toolBtn" data-tool="brightness">Brightness</button>
      <button class="toolBtn" data-tool="contrast">Contrast</button>
      <button class="toolBtn" data-tool="grayscale">Grayscale</button>
      <button class="toolBtn" data-tool="sepia">Sepia</button>
      <button class="toolBtn" data-tool="invert">Invert</button>
    </aside>

    <div id="canvasContainer" tabindex="0" aria-label="Image editing canvas">
      <input type="file" id="uploadInput" accept="image/*" />
      <button id="uploadBtn" title="Upload Image">Choose File</button>
      <canvas id="canvas" width="800" height="600"></canvas>
    </div>

    <aside id="sidebarRight" class="hide" aria-label="Tool properties">
      <h3>Properties</h3>
      <div id="toolProperties">Pilih tool dulu</div>
    </aside>
  </div>

  <footer>
    <button id="undoBtn" disabled>Undo</button>
    <button id="redoBtn" disabled>Redo</button>
    <button id="zoomInBtn">Zoom In</button>
    <button id="zoomOutBtn">Zoom Out</button>
    <button id="resetViewBtn">Reset View</button>
    <button id="saveBtn" disabled>Save</button>
    <button id="exportBtn" disabled>Export</button>
  </footer>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // State
  let img = new Image();
  let imgLoaded = false;
  let scale = 1;
  let offsetX = 0;
  let offsetY = 0;

  // Undo stack
  const undoStack = [];
  const redoStack = [];
  const maxHistory = 10;

  // Current tool and parameters
  let currentTool = null;
  let brushSize = 15;
  let eraserSize = 20;

  // Tool flags
  let isDrawing = false;
  let lastPos = null;

  // Sidebar toggle
  const sidebarLeft = document.getElementById('sidebarLeft');
  const sidebarRight = document.getElementById('sidebarRight');
  const menuToggle = document.getElementById('menuToggle');
  const closeSidebar = document.getElementById('closeSidebar');

  // Upload elements
  const uploadInput = document.getElementById('uploadInput');
  const uploadBtn = document.getElementById('uploadBtn');

  // Buttons
  const backBtn = document.getElementById('backBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetViewBtn = document.getElementById('resetViewBtn');
  const saveBtn = document.getElementById('saveBtn');
  const exportBtn = document.getElementById('exportBtn');

  // Tool buttons
  const toolButtons = document.querySelectorAll('.toolBtn');
  const toolProperties = document.getElementById('toolProperties');

  // Helper: Draw image on canvas with current scale and offset
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!imgLoaded) return;
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    ctx.drawImage(img, 0, 0);
    ctx.restore();
  }

  // Load image to canvas (and reset transforms)
  function loadImageToCanvas(image) {
    img = image;
    imgLoaded = true;
    scale = 1;
    offsetX = 0;
    offsetY = 0;

    // Resize canvas to fit image max 800x600 keeping ratio
    let w = img.width;
    let h = img.height;
    const maxW = 800;
    const maxH = 600;
    if(w > maxW){
      h = h * maxW / w;
      w = maxW;
    }
    if(h > maxH){
      w = w * maxH / h;
      h = maxH;
    }
    canvas.width = w;
    canvas.height = h;

    saveState(); // Save initial state
    draw();
    saveBtn.disabled = false;
    exportBtn.disabled = false;
  }

  // Save current canvas state to undo stack
  function saveState() {
    if(!imgLoaded) return;
    if(undoStack.length >= maxHistory){
      undoStack.shift();
    }
    undoStack.push(canvas.toDataURL());
    redoStack.length = 0;
    updateUndoRedoButtons();
  }

  function updateUndoRedoButtons() {
    undoBtn.disabled = undoStack.length <= 1;
    redoBtn.disabled = redoStack.length === 0;
  }

  // Undo action
  undoBtn.onclick = () => {
    if(undoStack.length > 1){
      const dataUrl = undoStack.pop();
      redoStack.push(dataUrl);
      const prev = undoStack[undoStack.length-1];
      restoreFromDataUrl(prev);
      updateUndoRedoButtons();
    }
  };

  // Redo action
  redoBtn.onclick = () => {
    if(redoStack.length > 0){
      const dataUrl = redoStack.pop();
      undoStack.push(dataUrl);
      restoreFromDataUrl(dataUrl);
      updateUndoRedoButtons();
    }
  };

  function restoreFromDataUrl(dataUrl) {
    const imgTmp = new Image();
    imgTmp.onload = () => {
      img = imgTmp;
      imgLoaded = true;
      canvas.width = img.width;
      canvas.height = img.height;
      draw();
    };
    imgTmp.src = dataUrl;
  }

  // Upload file handler
  uploadInput.addEventListener('change', e => {
    if(e.target.files.length === 0) return;
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = evt => {
      const image = new Image();
      image.onload = () => loadImageToCanvas(image);
      image.src = evt.target.result;
    };
    reader.readAsDataURL(file);
  });

  uploadBtn.onclick = () => {
    uploadInput.click();
  };

  // Tool selection
  toolButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      if(currentTool === btn.dataset.tool){
        // toggle off
        currentTool = null;
        btn.classList.remove('active');
        toolProperties.innerHTML = 'Pilih tool dulu';
        sidebarRight.classList.add('hide');
        canvas.style.cursor = 'default';
      } else {
        // select new tool
        currentTool = btn.dataset.tool;
        toolButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        updatePropertiesForTool(currentTool);
        sidebarRight.classList.remove('hide');
        canvas.style.cursor = currentTool==='brush' ? 'crosshair' : 'default';
      }
    });
  });

  // Update properties panel for selected tool
  function updatePropertiesForTool(tool) {
    let html = '';
    switch(tool){
      case 'brush':
        html = `<label>Brush Size: <input type="range" id="brushSize" min="1" max="50" value="${brushSize}"></label>`;
        break;
      case 'eraser':
        html = `<label>Eraser Size: <input type="range" id="eraserSize" min="1" max="50" value="${eraserSize}"></label>`;
        break;
      case 'brightness':
      case 'contrast':
        html = `<label>${tool.charAt(0).toUpperCase() + tool.slice(1)}: <input type="range" id="${tool}Range" min="-100" max="100" value="0"></label>`;
        break;
      case 'crop':
        html = `<p>Drag di canvas untuk memilih area crop, lalu klik Apply Crop di bawah.</p><button id="applyCropBtn">Apply Crop</button>`;
        break;
      case 'rotate':
        html = `<button id="rotateBtn">Putar 90°</button>`;
        break;
      case 'spotHealing':
        html = `<p>Gunakan kuas untuk menghapus noda dengan blur.</p><label>Brush Size: <input type="range" id="brushSize" min="1" max="50" value="${brushSize}"></label>`;
        break;
      case 'cloneStamp':
        html = `<p>Klik area sumber lalu kuas area target.</p><label>Brush Size: <input type="range" id="brushSize" min="1" max="50" value="${brushSize}"></label>`;
        break;
      default:
        html = `<p>Atur properti jika ada.</p>`;
    }
    toolProperties.innerHTML = html;

    // Add event listeners for sliders/buttons dynamically
    if(tool==='brush'){
      document.getElementById('brushSize').addEventListener('input', e => brushSize = +e.target.value);
    }
    if(tool==='eraser'){
      document.getElementById('eraserSize').addEventListener('input', e => eraserSize = +e.target.value);
    }
    if(tool==='brightness'){
      document.getElementById('brightnessRange').addEventListener('input', e => applyFilter('brightness', +e.target.value));
    }
    if(tool==='contrast'){
      document.getElementById('contrastRange').addEventListener('input', e => applyFilter('contrast', +e.target.value));
    }
    if(tool==='crop'){
      document.getElementById('applyCropBtn').addEventListener('click', applyCrop);
    }
    if(tool==='rotate'){
      document.getElementById('rotateBtn').addEventListener('click', rotateImage);
    }
    if(tool==='spotHealing'){
      document.getElementById('brushSize').addEventListener('input', e => brushSize = +e.target.value);
    }
    if(tool==='cloneStamp'){
      document.getElementById('brushSize').addEventListener('input', e => brushSize = +e.target.value);
    }
  }
  <script>
  // Crop selection vars
  let cropStart = null;
  let cropEnd = null;
  let isCropping = false;

  // Mouse/touch handlers for canvas
  function getCanvasPos(evt) {
    const rect = canvas.getBoundingClientRect();
    let x, y;
    if(evt.touches){
      x = evt.touches[0].clientX - rect.left;
      y = evt.touches[0].clientY - rect.top;
    } else {
      x = evt.clientX - rect.left;
      y = evt.clientY - rect.top;
    }
    return {x,y};
  }

  canvas.addEventListener('mousedown', startDrawing);
  canvas.addEventListener('touchstart', startDrawing);
  canvas.addEventListener('mousemove', drawOnCanvas);
  canvas.addEventListener('touchmove', drawOnCanvas);
  canvas.addEventListener('mouseup', stopDrawing);
  canvas.addEventListener('touchend', stopDrawing);
  canvas.addEventListener('mouseout', stopDrawing);

  function startDrawing(e){
    if(!currentTool) return;
    const pos = getCanvasPos(e);
    if(currentTool === 'crop'){
      cropStart = pos;
      cropEnd = null;
      isCropping = true;
      draw(); // redraw to clear selection
      drawCropRect();
    } else if(['brush','eraser','spotHealing','cloneStamp'].includes(currentTool)){
      isDrawing = true;
      lastPos = pos;
      saveState();
    }
  }

  function drawOnCanvas(e){
    if(!isDrawing) return;
    e.preventDefault();
    const pos = getCanvasPos(e);
    if(currentTool === 'brush'){
      drawBrush(pos);
    } else if(currentTool === 'eraser'){
      drawEraser(pos);
    } else if(currentTool === 'spotHealing'){
      drawSpotHealing(pos);
    }
    lastPos = pos;
  }

  function stopDrawing(e){
    if(currentTool === 'crop' && isCropping){
      isCropping = false;
    }
    if(isDrawing){
      isDrawing = false;
      saveState();
    }
  }

  function drawBrush(pos){
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);
  ctx.lineCap = "round";
  ctx.strokeStyle = "#0ff";
  ctx.lineWidth = brushSize;
  ctx.beginPath();
  ctx.moveTo(lastPos.x / scale, lastPos.y / scale);
  ctx.lineTo(pos.x / scale, pos.y / scale);
  ctx.stroke();
  ctx.restore();
  lastPos = pos;
}

function drawEraser(pos){
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);
  ctx.globalCompositeOperation = "destination-out";
  ctx.beginPath();
  ctx.arc(pos.x / scale, pos.y / scale, eraserSize / 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalCompositeOperation = "source-over";
  ctx.restore();
  lastPos = pos;
}

function drawSpotHealing(pos){
  // Simple blur placeholder: samples pixels around to blur
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  let radius = brushSize;
  let imageData = ctx.getImageData(
    pos.x / scale - radius,
    pos.y / scale - radius,
    radius * 2,
    radius * 2
  );

  // Naive blur by averaging pixels (very simple)
  for(let i=0; i < imageData.data.length; i+=4){
    imageData.data[i] = (imageData.data[i] + imageData.data[i+4] || imageData.data[i]) / 2;
    imageData.data[i+1] = (imageData.data[i+1] + imageData.data[i+5] || imageData.data[i+1]) / 2;
    imageData.data[i+2] = (imageData.data[i+2] + imageData.data[i+6] || imageData.data[i+2]) / 2;
  }

  ctx.putImageData(imageData, pos.x / scale - radius, pos.y / scale - radius);
  ctx.restore();
  lastPos = pos;
}

function drawCropRect(){
  if(!cropStart || !cropEnd) return;
  ctx.save();
  ctx.strokeStyle = "#0ff";
  ctx.lineWidth = 2;
  ctx.setLineDash([6]);
  let x = Math.min(cropStart.x, cropEnd.x);
  let y = Math.min(cropStart.y, cropEnd.y);
  let w = Math.abs(cropEnd.x - cropStart.x);
  let h = Math.abs(cropEnd.y - cropStart.y);
  ctx.strokeRect(x, y, w, h);
  ctx.restore();
}

canvas.addEventListener("mousemove", (e) => {
  if(currentTool === "crop" && isCropping){
    cropEnd = getCanvasPos(e);
    draw();
    drawCropRect();
  }
});
canvas.addEventListener("touchmove", (e) => {
  if(currentTool === "crop" && isCropping){
    cropEnd = getCanvasPos(e);
    draw();
    drawCropRect();
  }
});

function applyCrop(){
  if(!cropStart || !cropEnd) return alert("Pilih area crop dulu!");
  let x = Math.min(cropStart.x, cropEnd.x);
  let y = Math.min(cropStart.y, cropEnd.y);
  let w = Math.abs(cropEnd.x - cropStart.x);
  let h = Math.abs(cropEnd.y - cropStart.y);

  const croppedData = ctx.getImageData(x, y, w, h);

  canvas.width = w;
  canvas.height = h;

  ctx.clearRect(0, 0, w, h);
  ctx.putImageData(croppedData, 0, 0);

  saveState();

  cropStart = null;
  cropEnd = null;

  draw();
}

function rotateImage(){
  if(!imgLoaded) return;
  saveState();

  const tempCanvas = document.createElement("canvas");
  const tempCtx = tempCanvas.getContext("2d");
  tempCanvas.width = canvas.height;
  tempCanvas.height = canvas.width;

  tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
  tempCtx.rotate(Math.PI / 2);
  tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);

  canvas.width = tempCanvas.width;
  canvas.height = tempCanvas.height;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(tempCanvas, 0, 0);

  saveState();
}

function applyFilter(type, value){
  if(!imgLoaded) return;
  saveState();

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  if(type === "brightness"){
    const v = value * 2.55; 
    for(let i=0; i < data.length; i+=4){
      data[i] = clamp(data[i] + v);
      data[i+1] = clamp(data[i+1] + v);
      data[i+2] = clamp(data[i+2] + v);
    }
  } else if(type === "contrast"){
    const v = (value / 100) + 1;
    for(let i=0; i < data.length; i+=4){
      data[i] = clamp(((data[i]-128)*v)+128);
      data[i+1] = clamp(((data[i+1]-128)*v)+128);
      data[i+2] = clamp(((data[i+2]-128)*v)+128);
    }
  } else if(type === "grayscale"){
    for(let i=0; i < data.length; i+=4){
      const avg = (data[i] + data[i+1] + data[i+2])/3;
      data[i] = data[i+1] = data[i+2] = avg;
    }
  } else if(type === "sepia"){
    for(let i=0; i < data.length; i+=4){
      const r = data[i], g = data[i+1], b = data[i+2];
      data[i] = clamp(r*0.393 + g*0.769 + b*0.189);
      data[i+1] = clamp(r*0.349 + g*0.686 + b*0.168);
      data[i+2] = clamp(r*0.272 + g*0.534 + b*0.131);
    }
  } else if(type === "invert"){
    for(let i=0; i < data.length; i+=4){
      data[i] = 255 - data[i];
      data[i+1] = 255 - data[i+1];
      data[i+2] = 255 - data[i+2];
    }
  }
  ctx.putImageData(imageData, 0, 0);
}

function clamp(value){
  return Math.max(0, Math.min(255, value));
}

// Zoom and pan buttons
zoomInBtn.onclick = () => {
  scale = Math.min(5, scale + 0.2);
  draw();
};
zoomOutBtn.onclick = () => {
  scale = Math.max(0.2, scale - 0.2);
  draw();
};
resetViewBtn.onclick = () => {
  scale = 1;
  offsetX = 0;
  offsetY = 0;
  draw();
};

// Save and export
saveBtn.onclick = () => {
  alert("Fitur save lokal belum dibuat, implementasi opsional.");
};
exportBtn.onclick = () => {
  if(!imgLoaded) return;
  const dataUrl = canvas.toDataURL("image/png");
  const link = document.createElement("a");
  link.download = "edited_image.png";
  link.href = dataUrl;
  link.click();
};

// Sidebar toggle for mobile
menuToggle.onclick = () => {
  if(sidebarLeft.classList.contains("hide")){
    sidebarLeft.classList.remove("hide");
  } else {
    sidebarLeft.classList.add("hide");
  }
};
closeSidebar.onclick = () => {
  sidebarLeft.classList.add("hide");
};

// Back button resets everything
backBtn.onclick = () => {
  if(confirm("Reset semua dan mulai ulang?")){
    undoStack.length = 0;
    redoStack.length = 0;
    imgLoaded = false;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    saveBtn.disabled = true;
    exportBtn.disabled = true;
    toolButtons.forEach(b => b.classList.remove("active"));
    currentTool = null;
    sidebarRight.classList.add("hide");
  }
};

// Init default
saveState();
draw();
})();
</script>
